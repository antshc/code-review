= C# Nullable Reference Types (NRT) – Best Practices Cheat Sheet
:toc:
:toclevels: 2
:sectanchors:

This cheat sheet assumes C# Nullable Reference Types are enabled:

[source,xml]
----
<Nullable>enable</Nullable>
----

It focuses especially on reading data from *external systems* (JSON APIs, databases, third-party libraries), where nullability guarantees do not exist.

== 1. Treat External Data as Untrusted (Trust Boundary)

*Challenge*  
The compiler enforces null safety only inside your code. External systems may return missing, null, or malformed data.

*Best Practices*  
- Define explicit trust boundaries: external → validate/map → internal.
- Never pass DTOs directly into business logic.
- Perform validation and mapping in a dedicated adapter or mapper layer.

*Why This Matters*  
Nullable Reference Types protect *your* code paths, not data you do not control.

---

== 2. Nullable DTOs, Non-Nullable Domain Models

*Challenge*  
External models often allow nulls, while domain logic requires invariants.

*Best Practices*  
- Use nullable properties in DTOs where the source can return null.
- Map DTOs to non-nullable domain models after validation.
- Fail fast if required domain data is missing.

*Why This Matters*  
Prevents “nullable infection” and keeps domain logic simple and safe.

---

== 3. Use `required` Carefully (C# 11+)

*Challenge*  
`required` enforces initialization, but deserialization may bypass guarantees.

*Best Practices*  
- Use `required` for domain models created in code.
- Prefer nullable + validation for DTOs.
- Never rely on `required` alone for external data correctness.

*Why This Matters*  
`required` helps at compile time, not at runtime boundaries.

---

== 4. Avoid Overusing the Null-Forgiving Operator (`!`)

*Challenge*  
Warnings tempt developers to silence them with `!`.

*Best Practices*  
- Use `!` only after explicit guards or guaranteed invariants.
- Prefer guard clauses and pattern matching.
- Document the invariant when `!` is unavoidable.

*Why This Matters*  
Excessive `!` disables the safety benefits of NRT.

---

== 5. Guard All Public Boundaries

*Challenge*  
Public methods may receive invalid or null inputs.

*Best Practices*  
- Guard immediately using `ArgumentNullException.ThrowIfNull`.
- Validate strings for emptiness or whitespace.
- Keep guards at controllers, handlers, or public services.

*Why This Matters*  
Early validation simplifies downstream logic and prevents latent bugs.

---

== 6. Prefer Try-Patterns for Parsing External Data

*Challenge*  
IDs, enums, and dates from external sources may be invalid.

*Best Practices*  
- Use `TryParse` / `Enum.TryParse`.
- Create `TryCreate` methods for value objects.
- Avoid exceptions for normal validation failures.

*Why This Matters*  
Makes failure paths explicit, predictable, and testable.

---

== 7. Do Not Default Missing Values Silently

*Challenge*  
Using `x ?? ""` or `x ?? 0` hides invalid input.

*Best Practices*  
- Default values only when required by business rules.
- Otherwise, treat missing data as invalid.
- Centralize defaulting logic in mappers.

*Why This Matters*  
Silent defaults cause subtle data corruption and logic errors.

---

== 8. Avoid Returning `null` from Internal APIs

*Challenge*  
Returning null forces all callers to add defensive checks.

*Best Practices*  
- Use `TryGet` patterns.
- Return `Result<T>`, `Option<T>`, or similar.
- Return empty collections instead of null.

*Why This Matters*  
Reduces cognitive load and keeps internal APIs safer.

---

== 9. Model “Missing vs Null vs Empty” Explicitly

*Challenge*  
External systems blur semantic differences.

*Best Practices*  
- Define semantics per field and document them.
- Use nullable DTOs plus validation rules.
- Map explicitly into domain representations.

*Why This Matters*  
Many production bugs come from semantic ambiguity, not crashes.

---

== 10. Use Strict JSON Deserialization Rules

*Challenge*  
JSON payloads may contain invalid types or missing fields.

*Best Practices*  
- Reject invalid enums and unexpected shapes.
- Validate required fields explicitly.
- Add contract tests with invalid payloads.

*Why This Matters*  
Runtime validation is the only protection against malformed JSON.

---

== 11. Separate DTOs from Domain Models

*Challenge*  
Using a single model for everything leads to nullability leaks.

*Best Practices*  
- Keep DTOs stable and versioned.
- Map DTO → domain explicitly.
- Prefer source-generated serializers where performance matters.

*Why This Matters*  
Improves evolution safety and reduces accidental null propagation.

---

== 12. Expect Nulls from Databases

*Challenge*  
Schema drift, joins, and raw SQL can return nulls.

*Best Practices*  
- Align C# nullability with DB schema.
- Treat raw SQL results as untrusted.
- Map DB models to domain models in repositories.

*Why This Matters*  
Database mismatches are a common source of runtime failures.

---

== 13. Treat Non-Annotated Libraries as Nullable

*Challenge*  
Older libraries may lack nullability annotations.

*Best Practices*  
- Assume return values may be null.
- Wrap libraries in adapters with validation.
- Prefer libraries with NRT annotations when possible.

*Why This Matters*  
Compiler trust without annotations is false confidence.

---

== 14. Keep Nullable Warnings Clean

*Challenge*  
Warning fatigue leads to global suppressions.

*Best Practices*  
- Fix warnings or suppress locally with justification.
- Avoid `#nullable disable` except in legacy code.
- Consider treating nullable warnings as errors in mature codebases.

*Why This Matters*  
A clean warning baseline preserves signal quality.

---

== 15. Prefer Non-Nullable Collections

*Challenge*  
Nullable collections force repeated null checks.

*Best Practices*  
- Use non-nullable collections and return empty ones.
- Normalize null collections at boundaries.
- Decide and document null vs empty semantics.

*Why This Matters*  
Eliminates an entire category of defensive code.

---

== 16. Use Nullability Attributes When Needed

*Challenge*  
The compiler may not infer custom validation logic.

*Best Practices*  
- Use attributes like:
  - `[NotNullWhen(true)]`
  - `[MaybeNull]`
  - `[DoesNotReturn]`
- Annotate helper and guard methods.

*Why This Matters*  
Improves static analysis without unsafe operators.

---

== 17. Be Defensive in Logging and Error Paths

*Challenge*  
Exception paths often involve partially initialized objects.

*Best Practices*  
- Log defensively using null-coalescing.
- Prefer structured logging.
- Avoid calling `.ToString()` on possibly null values.

*Why This Matters*  
Prevents secondary failures during error handling.

---

== 18. Test Null and Invalid Scenarios Explicitly

*Challenge*  
Happy-path tests do not reveal nullability bugs.

*Best Practices*  
- Test missing fields, nulls, and invalid enums.
- Maintain real payload samples (valid and invalid).
- Include boundary tests by default.

*Why This Matters*  
Nullable Reference Types reduce risk, tests prove correctness.

---

== Summary Rule

*External data is nullable by default.  
Internal code should be non-nullable by design.*

Enforce this rule consistently, and Nullable Reference Types become a powerful correctness tool rather than noise.
