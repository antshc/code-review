= C# Nullable Reference Types (NRT) – Best Practices Cheat Sheet
:toc:
:toclevels: 2
:sectnums:

This cheat sheet focuses on best practices when *Nullable Reference Types* are enabled in C#, especially when dealing with *external systems* such as REST APIs (JSON), databases, configuration, and third-party libraries.

== 1. Treat external input as nullable by default

=== Challenge
External systems may return missing fields, `null` values, empty strings, or unexpected payload shapes — even if documentation claims otherwise.

=== Best practices (with example)
Model inbound data with nullable properties and validate at the boundary before mapping to internal models.

[source,csharp]
----
#nullable enable

public sealed record ExternalUserDto(
    string? Id,
    string? Email,
    string? Name
);

public sealed record User(
    string Id,
    string Email,
    string Name
);

public static class UserMapper
{
    public static User ToDomain(ExternalUserDto dto)
    {
        var id = dto.Id?.Trim();
        var email = dto.Email?.Trim();
        var name = dto.Name?.Trim();

        if (string.IsNullOrEmpty(id))
            throw new InvalidDataException("User.Id is missing");

        if (string.IsNullOrEmpty(email))
            throw new InvalidDataException("User.Email is missing");

        if (string.IsNullOrEmpty(name))
            name = "(unknown)";

        return new User(id, email, name);
    }
}
----

=== Why this matters
Null-handling stays *localized at the boundary*. The rest of the codebase can rely on non-null invariants and avoid defensive checks.

== 2. Use boundary validation and internal invariants

=== Challenge
Spreading nullable reference types throughout the domain leads to excessive `?.`, `??`, and fragile logic.

=== Best practices (with example)
Validate once at the boundary, then enforce non-null invariants internally.

[source,csharp]
----
public sealed class Order
{
    public string OrderId { get; }
    public string CustomerId { get; }

    public Order(string orderId, string customerId)
    {
        OrderId = string.IsNullOrWhiteSpace(orderId)
            ? throw new ArgumentException("orderId is required", nameof(orderId))
            : orderId;

        CustomerId = string.IsNullOrWhiteSpace(customerId)
            ? throw new ArgumentException("customerId is required", nameof(customerId))
            : customerId;
    }
}
----

=== Why this matters
Internal code becomes simpler, safer, and easier to reason about because invariants are guaranteed.

== 3. Use `required` for internal models, avoid it for external DTOs

=== Challenge
`required` members can be bypassed by deserializers and external frameworks.

=== Best practices (with example)
Use `required` only where object creation is fully under your control.

[source,csharp]
----
public sealed class InternalConfig
{
    public required string Endpoint { get; init; }
    public required string ApiKey { get; init; }
}
----

External DTOs should remain nullable and validated explicitly.

=== Why this matters
You get compile-time safety without relying on runtime deserialization guarantees.

== 4. Avoid the null-forgiving operator (`!`) except with proof

=== Challenge
The null-forgiving operator suppresses warnings and can hide real bugs.

=== Best practices (with example)
Prefer explicit checks or pattern matching.

[source,csharp]
----
if (dto.Email is null)
    throw new InvalidDataException("Email missing");

var email = dto.Email; // non-null here
----

If unavoidable, document the invariant clearly.

[source,csharp]
----
var userName = httpContext.User.Identity!.Name!;
// Identity and Name are guaranteed for authenticated requests
----

=== Why this matters
Uncontrolled use of `!` defeats the purpose of nullable reference types.

== 5. Guard public APIs aggressively

=== Challenge
Public methods are called by code you do not control.

=== Best practices (with example)
Use built-in guard helpers.

[source,csharp]
----
public void Process(User user)
{
    ArgumentNullException.ThrowIfNull(user);
}
----

Validate strings and value semantics explicitly.

=== Why this matters
Fail-fast behavior improves diagnostics and prevents deep null-reference failures.

== 6. Use `Try*` patterns for messy external data

=== Challenge
External systems may return invalid but non-null values.

=== Best practices (with example)
Use parsing helpers that distinguish invalid from missing.

[source,csharp]
----
public static int? ParseAgeOrNull(string? raw)
    => int.TryParse(raw, out var v) ? v : null;
----

=== Why this matters
Avoids conflating invalid data with valid defaults.

== 7. Match database nullability explicitly

=== Challenge
Database schemas often allow nulls that do not map cleanly to domain rules.

=== Best practices (with example)
Reflect DB nullability in data models and map to domain types.

[source,csharp]
----
public sealed class UserRow
{
    public string Id { get; set; } = default!;
    public string? MiddleName { get; set; }
}

public sealed record UserDomain(string Id, string MiddleName);

public static UserDomain ToDomain(UserRow row)
{
    ArgumentNullException.ThrowIfNull(row);
    return new UserDomain(row.Id, row.MiddleName ?? "");
}
----

=== Why this matters
Separates persistence concerns from domain invariants.

== 8. Validate JSON after deserialization

=== Challenge
JSON deserializers may ignore missing fields or silently coerce values.

=== Best practices (with example)
Always validate deserialized objects.

[source,csharp]
----
var dto = JsonSerializer.Deserialize<ExternalUserDto>(json)
          ?? throw new InvalidDataException("Invalid JSON payload");
----

=== Why this matters
Deserializer configuration does not replace business validation.

== 9. Never return null collections

=== Challenge
Null collections force null checks at every call site.

=== Best practices (with example)
Default missing collections to empty ones.

[source,csharp]
----
var items = dto.Items ?? new List<string>();
----

Prefer `IReadOnlyList<T>` or immutable collections in APIs.

=== Why this matters
Eliminates an entire class of null-reference errors.

== 10. Use guard helpers to keep mapping readable

=== Challenge
Boundary validation can become verbose and repetitive.

=== Best practices (with example)
Centralize validation logic.

[source,csharp]
----
public static class Guard
{
    public static string Required(string? value, string name)
        => string.IsNullOrWhiteSpace(value)
            ? throw new InvalidDataException($"{name} is required")
            : value;
}
----

=== Why this matters
Improves consistency and readability across the codebase.

== 11. Model domain states explicitly instead of using null

=== Challenge
`null` often conflates multiple meanings (missing, unknown, invalid).

=== Best practices (with example)
Use enums or explicit state objects.

[source,csharp]
----
public enum AvailabilityState
{
    InStock,
    OutOfStock,
    Unknown
}
----

=== Why this matters
Makes invalid states unrepresentable and logic clearer.

== 12. Keep nullable warnings meaningful

=== Challenge
Too many warnings lead to warning fatigue and ignored diagnostics.

=== Best practices
- Enable NRT globally: `<Nullable>enable</Nullable>`
- Fix warnings in new or modified code
- Use targeted suppressions with justification

=== Why this matters
Nullable reference types only add value when warnings are trusted.

== 13. Annotate public APIs accurately

=== Challenge
Consumers rely on your annotations for correctness.

=== Best practices (with example)
Be explicit in return types.

[source,csharp]
----
public string? TryGetDisplayName(User user);
public string GetId(User user);
----

=== Why this matters
Improves correctness and usability for downstream consumers.

== 14. Avoid masking bugs with default values

=== Challenge
Blindly applying defaults can hide data-quality issues.

=== Best practices (with example)
Default only when acceptable; otherwise fail fast.

[source,csharp]
----
var nickname = dto.Nickname?.Trim() ?? "(none)";
----

[source,csharp]
----
var id = dto.Id?.Trim()
    ?? throw new InvalidDataException("Id missing");
----

=== Why this matters
Silent defaults turn data issues into business bugs.

== 15. Be careful with structs that contain reference-type fields

=== Challenge
When a `struct` contains reference-type fields, initializing it with `default` (or `new()` without arguments) does *not* trigger nullable warnings — even when Nullable Reference Types are enabled.

This can silently introduce `null` values into code that appears safe.

=== Best practices (with example)

[source,csharp]
----
#nullable enable

public struct CacheEntry
{
    public string Key;     // reference type
    public byte[] Buffer;  // reference type
}

// No compiler warning here
CacheEntry entry = default;

// Runtime NullReferenceException risk
int length = entry.Key.Length;
----

Why this happens:
- `struct` default initialization zeroes all fields
- reference-type fields become `null`
- NRT analysis does **not** warn on `default(struct)` usage

==== Recommended patterns

*Avoid reference-type fields in structs*  
Prefer `class` or `record class` when references are required.

[source,csharp]
----
public sealed class CacheEntry
{
    public required string Key { get; init; }
    public required byte[] Buffer { get; init; }
}
----

*If struct is required (performance / interop), enforce full initialization*

[source,csharp]
----
public readonly struct CacheEntry
{
    public string Key { get; }
    public byte[] Buffer { get; }

    public CacheEntry(string key, byte[] buffer)
    {
        Key = key ?? throw new ArgumentNullException(nameof(key));
        Buffer = buffer ?? throw new ArgumentNullException(nameof(buffer));
    }
}
----

*Avoid `default` usage explicitly*

[source,csharp]
----
CacheEntry entry = new CacheEntry("key", data); // safe
// CacheEntry entry = default; // avoid
----

*Optionally add runtime guard (debug builds)*

[source,csharp]
----
public void Validate()
{
    Debug.Assert(Key != null);
    Debug.Assert(Buffer != null);
}
----

=== Why this matters
This is one of the **most dangerous NRT blind spots**:
- No compiler warning
- Looks safe at call site
- Fails later with `NullReferenceException`

In high-reliability systems, structs with reference-type fields should be treated as *unsafe by default* unless construction is strictly controlled.

== 16. Arrays do not protect you from null elements

=== Challenge
When an array is created, its elements are initialized with default values.
For reference types, this means **each element is `null`**, and **Nullable Reference Types do not warn** about this.

This creates a false sense of safety: the array itself is non-null, but its elements are not.

=== Best practices (with example)

[source,csharp]
----
#nullable enable

string[] names = new string[3]; // No compiler warning

// Runtime NullReferenceException
int length = names[0].Length;
----

Why this happens:
- Arrays are zero-initialized
- Reference-type elements default to `null`
- NRT tracks the array reference, not per-element initialization

==== Recommended patterns

*Always initialize array elements explicitly*

[source,csharp]
----
var names = new string[3];
for (int i = 0; i < names.Length; i++)
{
    names[i] = string.Empty;
}
----

*Prefer collection initializers when possible*

[source,csharp]
----
string[] names = { "Alice", "Bob", "Charlie" };
----

*Use nullable element types when null is a valid state*

[source,csharp]
----
string?[] names = new string?[3];
----

This forces callers to acknowledge the possibility of null elements.

*Prefer immutable or read-only collections for safety*

[source,csharp]
----
IReadOnlyList<string> names = new List<string> { "Alice", "Bob" };
----

*Encapsulate arrays behind validated APIs*

[source,csharp]
----
public sealed class NameList
{
    private readonly string[] _names;

    public NameList(string[] names)
    {
        if (names.Any(n => n is null))
            throw new ArgumentException("Array contains null element");

        _names = names;
    }

    public string this[int index] => _names[index];
}
----

=== Why this matters
This is another **NRT blind spot**:
- No compiler warning
- Very common with buffers, caches, and DTOs
- Failures occur far from the allocation site

Rule of thumb:
*Arrays guarantee size, not element validity.*

If element nullability matters, make it **explicit** in the type system or enforce initialization immediately.

== 17. Configure System.Text.Json to strictly enforce NRT and collection element nullability (ASP.NET + HttpClient)

=== Challenge
Nullable Reference Types (NRT) are compile-time checks, but JSON deserialization happens at runtime.
Without explicit configuration, `System.Text.Json` may deserialize payloads that violate your non-nullable contracts, including:
- `null` assigned to non-nullable properties
- missing required constructor parameters
- `null` elements inside JSON arrays

This creates objects that look safe to the compiler but fail later at runtime.

=== Best practices (with example)
Enable strict JSON settings so runtime behavior matches your NRT intent, in *both*:
- inbound API requests (ASP.NET Core)
- outbound calls to external systems (HttpClient)

==== A) ASP.NET Core (Minimal APIs / Controllers)

*Minimal APIs / HttpClient JSON defaults for the app:*

[source,csharp]
----
builder.Services.ConfigureHttpJsonOptions(options =>
{
    options.SerializerOptions.RespectNullableAnnotations = true;
    options.SerializerOptions.RespectRequiredConstructorParameters = true;

    // Optional: insert source-generated or custom resolver first
    // options.SerializerOptions.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);
});
----

*Controllers:*

[source,csharp]
----
builder.Services.AddControllers().AddJsonOptions(options =>
{
    options.JsonSerializerOptions.RespectNullableAnnotations = true;
    options.JsonSerializerOptions.RespectRequiredConstructorParameters = true;
});
----

==== B) HttpClient (Typed client + HttpClientFactory) — recommended

Create a shared options instance and use it in your typed client.
This ensures the same strict behavior for all external HTTP JSON calls.

[source,csharp]
----
using System.Net.Http.Json;
using System.Text.Json;

#nullable enable

public sealed class ExternalApiClient
{
    private readonly HttpClient _http;
    private readonly JsonSerializerOptions _json;

    public ExternalApiClient(HttpClient http)
    {
        _http = http;

        _json = new JsonSerializerOptions(JsonSerializerDefaults.Web)
        {
            RespectNullableAnnotations = true,
            RespectRequiredConstructorParameters = true
        };

        // Optional: if using source-gen context/resolver
        // _json.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);
    }

    public async Task<UserDto> GetUserAsync(string id, CancellationToken ct)
    {
        // Strict: will throw if payload violates NRT (null for non-nullable, null array element, etc.)
        var dto = await _http.GetFromJsonAsync<UserDto>($"/users/{id}", _json, ct)
                  ?? throw new InvalidDataException("Empty JSON payload");

        return dto;
    }
}

public sealed record UserDto(string Id, string[] Roles); // non-nullable contracts
----

Register as typed client:

[source,csharp]
----
builder.Services.AddHttpClient<ExternalApiClient>(c =>
{
    c.BaseAddress = new Uri("https://api.example.com");
});
----

==== C) HttpClient (Manual) — when you don't use GetFromJsonAsync

If you read the response as a stream/string and call `JsonSerializer.Deserialize`, pass the same strict options.

[source,csharp]
----
var json = await http.GetStringAsync("/users/123", ct);

var dto = JsonSerializer.Deserialize<UserDto>(json, _json)
          ?? throw new InvalidDataException("Invalid JSON payload");
----

==== Runtime behavior with JSON arrays

Given these settings, element nullability is enforced:

[source,csharp]
----
public sealed record Payload(string[] Names);
----
JSON:
[source,json]
----
{ "names": ["Alice", null] }
----
*Result:* ❌ Deserialization fails (`JsonException`)

[source,csharp]
----
public sealed record Payload(string?[] Names);
----
JSON:
[source,json]
----
{ "names": ["Alice", null] }
----
*Result:* ✅ Deserialization succeeds, element is `null`

The same applies to `List<T>`, `IReadOnlyList<T>`, and constructor parameters.

==== Practical recommendation for external APIs
Treat external payloads as untrusted:
- DTOs may be nullable (`string?`, `T?[]`) if the provider can send nulls
- Map DTOs -> Domain models after validation
- Keep domain models non-nullable and invariant-driven

=== Why this matters
This rule closes one of the largest gaps between compile-time nullability intent and runtime data:
- Invalid payloads are rejected immediately at the boundary (inbound and outbound)
- Non-nullable contracts are enforced consistently
- Array/collection element nullability is no longer a hidden blind spot

**Rule of thumb:**
If `null` is not a valid value (or element), encode that rule in the type system and configure the serializer to fail fast when external data violates it.



== Rules of Thumb Summary

* External inputs: nullable + validate + map
* Internal domain: non-null by default
* Avoid spreading `?` in core logic
* Minimize `!`
* Never return null collections
