= Async/Await Best Practices (C# .NET 8+)

== 1. Avoid Blocking on Tasks
* Never use `task.Wait()` or `task.Result`
* Prefer using `await` all the way down
* If blocking is unavoidable (legacy scenarios), use:
+
[source,csharp]
----
task.GetAwaiter().GetResult();
----

== 2. Fire-and-Forget Tasks
* Avoid unhandled fire-and-forget calls
* Use helper methods such as `SafeFireAndForget()`
* Ensure exceptions are observed and logged

== 3. Avoid `return await` When Unnecessary
* Simplify:
+
[source,csharp]
----
public Task<int> FooAsync() => BarAsync();
----
* Use `async`/`await` only when:
** Wrapping in `try/catch`
** Using `using` or `await using`
** Additional logic is required before/after the await

== 4. Use `ConfigureAwait(false)` Appropriately
* Use when you do NOT need to resume on the captured context
* Relevant only when a SynchronizationContext exists
* Frameworks where it matters:
** ‚úî WPF
** ‚úî WinForms
** ‚úî Xamarin
** ‚úî .NET MAUI
** ‚úî WinUI
** ‚úî Blazor (Server)
** ‚ùå ASP.NET Core (no classic sync context)

== 5. Use `ConfigureAwait(ConfigureAwaitOptions options)`
* `ContinueOnCapturedContext` ‚Äì Attempts to resume on captured thread
* `ForceYielding` ‚Äì Forces yielding even if the Task is already complete
* `SuppressThrowing` ‚Äì Suppresses exception propagation
* `None` ‚Äì Will not return to captured context
* Options can be combined as flags

== 6. Use `ValueTask` for Optimized Hot Paths
* Useful when the common execution path completes synchronously
* Reduces allocations vs. always returning `Task`
* Be aware of limitations (cannot await multiple times, careful when storing)

== 7. Use `IAsyncEnumerable<T>` for Streaming Scenarios
* Enables progressive streaming of results
* Improves UI responsiveness and user experience
* Use `[EnumeratorCancellation]` to bind cancellation token:
+
[source,csharp]
----
async IAsyncEnumerable<Item> FetchAsync(
    [EnumeratorCancellation] CancellationToken ct = default)
{
}
----

== 8. Add Cancellation to Non-Cancelable APIs with `WaitAsync`
* Allows adding timeout/cancellation to Tasks that lack it
* Example:
+
[source,csharp]
----
await SomeOperationAsync().WaitAsync(ct);
----
* Note:
** Does NOT cancel a completed Task
** Does NOT cancel underlying operation if API doesn't support cancellation

== 9. Use `IAsyncDisposable` with `await using`
* For resources requiring async cleanup
+
[source,csharp]
----
await using var stream =
    new FileStream(path, FileMode.OpenOrCreate).ConfigureAwait(false);

// work with stream
// DisposeAsync() is awaited at the end of block
----
* `CancellationToken` not yet supported for async dispose

== 10. Task Considerations
* Be careful when using `Task.Run`:
** Appropriate for CPU-bound parallel work
** Do not wrap async I/O in `Task.Run`
* Avoid `ThreadStatic` in async code:
** Thread switching breaks semantics
** Use `AsyncLocal<T>` instead
* Always validate Tasks:
** Avoid ignoring returned `Task`
** Ensure exceptions are observed, logged or handled

== 11. Prefer `async` All the Way Down
* Do not create synchronous wrappers over async APIs (sync-over-async)
** Leads to deadlocks, thread pool starvation and poor scalability
* If a lower layer is async, keep your higher layers async too
* Only the true "edge" of the app (e.g., `Main` in console, legacy entry point) may need to block

== 12. Avoid `async void` (Except for Event Handlers)
* Use `Task` / `Task<T>` return types for async methods
* `async void`:
** Cannot be awaited
** Exceptions crash the process (or go to synchronization context handlers)
* Acceptable only for:
** UI event handlers (e.g., button click in WPF/WinForms/MAUI)
** Some fire-and-forget cases that are wired to global error logging

== 14. Cancellation Tokens Everywhere
* Prefer APIs that accept `CancellationToken`:
+
[source,csharp]
----
Task DoWorkAsync(CancellationToken cancellationToken = default);
----
* Propagate tokens down the call stack
* Check for `cancellationToken.IsCancellationRequested` in longer operations as needed
* Use `ThrowIfCancellationRequested()` when appropriate

== 15. Handle Exceptions Explicitly in Async Code
* Wrap awaited calls in `try/catch` where failures are expected:
+
[source,csharp]
----
try
{
    await DoWorkAsync(ct);
}
catch (OperationCanceledException)
{
    // expected, respect cancellation
}
catch (Exception ex)
{
    // log and handle
}
----
* Do not swallow exceptions silently
* For fire-and-forget code, ensure exceptions are logged or reported

== 16. Use `Task.WhenAll` / `Task.WhenAny` for Concurrency
* When tasks can run in parallel:
+
[source,csharp]
----
var tasks = items.Select(i => ProcessItemAsync(i, ct));
await Task.WhenAll(tasks);
----
* Avoid accidental sequential awaits in loops when concurrency is desired
* Limit degree of parallelism if the downstream resource can‚Äôt handle full fan-out

== 17. Don‚Äôt Do Heavy CPU Work Inside Async Methods
* Async is mainly for I/O-bound work
* For CPU-bound work on UI / request threads:
** Move it to the thread pool using `Task.Run` at the **edge**:
+
[source,csharp]
----
await Task.Run(() => CpuBoundWork(), ct);
----
* Keep the inner libraries pure (no `Task.Run` inside libraries)

== 18. Avoid Capturing Ambient State Unintentionally

=== ‚ùå Bad Example (captures entire object and fields)
[source,csharp]
----
public class FileProcessor
{
    private readonly byte[] _largeBuffer = new byte[10_000_000]; // 10 MB buffer

    public async Task ProcessFilesAsync(IEnumerable<string> files)
    {
        // BAD: The lambda captures `this` and `_largeBuffer`
        var tasks = files.Select(async file =>
        {
            // `_largeBuffer` is captured even if not needed
            await SaveToStorageAsync(file);
        });

        await Task.WhenAll(tasks);
    }

    private Task SaveToStorageAsync(string filePath) =>
        Task.Delay(10); // simulation
}

----

=== ‚úî Good Example (captures only required data)

[source,csharp]
----
public class FileProcessor
{
    private readonly byte[] _largeBuffer = new byte[10_000_000]; // 10 MB

    public async Task ProcessFilesAsync(IEnumerable<string> files)
    {
        // extract needed data BEFORE entering lambda
        var tasks = files.Select(file => ProcessSingleFileAsync(file));

        await Task.WhenAll(tasks);
    }

    private async Task ProcessSingleFileAsync(string filePath)
    {
        // Only the parameters are captured ‚Äî not `this` and not `_largeBuffer`
        await SaveToStorageAsync(filePath);
    }

    private Task SaveToStorageAsync(string filePath) =>
        Task.Delay(10); // simulation
}

----

=== üëç Why this is better

* The async method ProcessSingleFileAsync captures only **filePath**, avoiding closure over the entire class.
* The _largeBuffer and this are not captured unless explicitly used.
* More efficient memory usage, fewer retained references, smaller state machines.

=== ‚úî Better Example (captures only required data)
[source,csharp]
----
public async Task ProcessAsync(IEnumerable<string> files)
{
    var tasks = files.Select(ProcessFileAsync); // no closure, no capture
    await Task.WhenAll(tasks);
}

private Task ProcessFileAsync(string file) => SaveAsync(file);
----

=== üëç Why This Is Better
* Avoids capturing `this` and large fields unintentionally
* Produces smaller async state machines
* Reduces memory usage and garbage collection pressure
* Eliminates hidden allocations caused by closures


== 19. Be Careful with `TaskCompletionSource`
* Use only when you *must* bridge callback/legacy patterns to `Task`
* Always specify `TaskCreationOptions.RunContinuationsAsynchronously` to avoid inline re-entrancy issues
* Complete `TaskCompletionSource` exactly once (success, error, or cancellation)

== 20. Measure Before Optimizing Async Code
* Async adds overhead; do not over-async everything
* Use profiling/metrics to:
** Detect too many small awaits (context switches)
** Decide when `ValueTask` or batching is actually beneficial


